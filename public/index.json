
[{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/categories/ai/","section":"Categories","summary":"","title":"Ai","type":"categories"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/tags/ai/","section":"Categories","summary":"","title":"Ai","type":"tags"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/categories/algotrading/","section":"Categories","summary":"","title":"Algotrading","type":"categories"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/tags/algotrading/","section":"Categories","summary":"","title":"Algotrading","type":"tags"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/","section":"nenjo.tech","summary":"","title":"nenjo.tech","type":"page"},{"content":" When the Tools Start Thinking for You # It‚Äôs easy to see why AI has made its way into trading. Machine learning models promise to analyze more data than a human ever could. They can spot patterns, generate entry signals, and even write code to automate strategies. With a few clicks, you can spin up a trading bot that claims to be smarter, faster, and more accurate than anything you could design by hand. For traders tired of screen time and emotional decisions, it sounds like a dream. But here‚Äôs the problem. Most traders using AI aren‚Äôt using it to assist their thinking. They‚Äôre using it to replace it. That‚Äôs where things go wrong. Photos by nenjo What Happens When You Rely on Vibes, Not Context # AI tools can now generate entire Pine Script or Python trading bots with a single prompt. You type in a vague idea, and it spits out a working script. It might look clean. It might backtest well. It might even place a few decent trades. But under the surface, you don‚Äôt know why it works. Or if it even works for the market you‚Äôre in. You‚Äôre not building a strategy anymore. You‚Äôre just using someone else‚Äôs logic ‚Äî copied, repackaged, and abstracted through layers of code you didn‚Äôt write and don‚Äôt fully understand. That‚Äôs not trading. That‚Äôs vibe coding. It‚Äôs relying on something that feels smart because it looks smart. But there‚Äôs no context, no real insight into price action, and no connection to the actual structure of the market. And when things shift ‚Äî when the trend breaks or volatility changes ‚Äî you‚Äôre flying blind.\nFalse Positives Look Like Wins‚Ä¶ Until They Don‚Äôt # One of the biggest risks with AI-generated strategies is the illusion of effectiveness. A backtest might show a 70+% win rate. You see smooth equity curves and low drawdowns. But what you‚Äôre looking at might be curve-fitted, cherry-picked, or over-optimized for a narrow slice of data. It‚Äôs easy to create a strategy that performs well on paper. It‚Äôs much harder to design one that adapts to real market conditions ‚Äî news, macro trends, liquidity shifts, or human behavior. AI doesn‚Äôt care about these factors unless you explicitly feed them into the system. And most traders don‚Äôt. They‚Äôre trusting outputs from models trained on price alone. No fundamentals. No order flow. No market psychology. And in real-world trading, those missing inputs matter. The result? Strategies that perform well for a few days or weeks, then collapse without warning. And when that happens, you‚Äôre left with code you can‚Äôt fix and trades you can‚Äôt explain. Photos by nenjo The Real Power of AI Is in Enhancement, Not Replacement # AI isn‚Äôt the enemy. In fact, it can be a powerful partner ‚Äî if you know how to use it. The danger is in treating it like a magic black box that can outsmart the market on its own. It can‚Äôt. The strongest traders use AI to speed up analysis, generate ideas, or automate repetitive tasks. But they never stop thinking. They don‚Äôt outsource the core decision-making. They treat AI like a tool, not a substitute for skill. That‚Äôs the difference between responsible automation and blind delegation. Because when you don‚Äôt understand your own system, you‚Äôre not trading. You‚Äôre just pushing buttons and hoping the model gets it right. And hope isn‚Äôt a strategy.\nThe Bottom Line # If you\u0026rsquo;re using AI in your trading, be honest with yourself:\nDo you understand the logic behind your strategy? Can you explain why it wins ‚Äî and why it might lose? Are you trading a system, or are you trusting a script you didn‚Äôt write? The future of trading will include AI. That‚Äôs inevitable. But the traders who last are the ones who combine it with real insight, real discipline, and real understanding.\nAnything less is gambling with prettier code.\n","date":"15 July 2025","externalUrl":null,"permalink":"/posts/the-danger-of-using-ai-in-trading-why-blind-automation-is-riskier-than-you-think/","section":"Posts","summary":"One of the biggest risks with AI-generated strategies is the illusion of effectiveness.","title":"The Danger of Using AI in Trading: Why Blind Automation Is Riskier Than You Think","type":"posts"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/categories/trading/","section":"Categories","summary":"","title":"Trading","type":"categories"},{"content":"","date":"15 July 2025","externalUrl":null,"permalink":"/tags/trading/","section":"Categories","summary":"","title":"Trading","type":"tags"},{"content":"Hey, I‚Äôm Nenjo ‚Äî a software engineer with over a decade of experience building scalable systems, backend architectures, and automation tools that don‚Äôt crash‚Ä¶ most of the time.\nI created nenjo.tech to document the stuff I wish someone had written when I started: real-world insights about programming languages (like Go, Python, and even the occasional battle with C++), clean software architecture, design patterns that actually matter, and my ongoing journey building automated trading bots for Forex, gold, and crypto markets.\nIf you‚Äôre a fellow dev, trader, or just someone who enjoys solving ridiculously complex problems for fun ‚Äî welcome. This blog is for you.\nExpect code, crashes, solutions, and maybe some sarcasm ‚Äî all in the name of better engineering and smarter trading.\n","date":"14 July 2025","externalUrl":null,"permalink":"/about/","section":"About Me","summary":"\u003cp\u003eHey, I‚Äôm Nenjo ‚Äî a software engineer with over a decade of experience building scalable systems, backend architectures, and automation tools that don‚Äôt crash‚Ä¶ most of the time.\u003c/p\u003e\n\u003cp\u003eI created nenjo.tech to document the stuff I wish someone had written when I started: real-world insights about programming languages (like Go, Python, and even the occasional battle with C++), clean software architecture, design patterns that actually matter, and my ongoing journey building automated trading bots for Forex, gold, and crypto markets.\u003c/p\u003e","title":"About Me","type":"about"},{"content":"","date":"14 July 2025","externalUrl":null,"permalink":"/tags/","section":"Categories","summary":"","title":"Categories","type":"tags"},{"content":"","date":"14 July 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/categories/expert-advisor/","section":"Categories","summary":"","title":"Expert Advisor","type":"categories"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/tags/expert-advisor/","section":"Categories","summary":"","title":"Expert Advisor","type":"tags"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/categories/golang/","section":"Categories","summary":"","title":"Golang","type":"categories"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/tags/golang/","section":"Categories","summary":"","title":"Golang","type":"tags"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/categories/mq5/","section":"Categories","summary":"","title":"Mq5","type":"categories"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/tags/mq5/","section":"Categories","summary":"","title":"Mq5","type":"tags"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/categories/mt5/","section":"Categories","summary":"","title":"Mt5","type":"categories"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/tags/mt5/","section":"Categories","summary":"","title":"Mt5","type":"tags"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/categories/python/","section":"Categories","summary":"","title":"Python","type":"categories"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/tags/python/","section":"Categories","summary":"","title":"Python","type":"tags"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/categories/software-engineering/","section":"Categories","summary":"","title":"Software Engineering","type":"categories"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/tags/software-engineering/","section":"Categories","summary":"","title":"Software Engineering","type":"tags"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/categories/tradingbot/","section":"Categories","summary":"","title":"Tradingbot","type":"categories"},{"content":"","date":"12 July 2025","externalUrl":null,"permalink":"/tags/tradingbot/","section":"Categories","summary":"","title":"Tradingbot","type":"tags"},{"content":" The Dream of Passive Trading # It usually starts with a dream. You‚Äôve developed a strategy, maybe it‚Äôs a clean RSI divergence setup or a price action pattern you‚Äôve been back testing for weeks. It works. You‚Äôre winning more than you‚Äôre losing.\nThen it hits you: \u0026ldquo;Why not automate it?\u0026rdquo;\nThe idea sounds perfect. No more missed entries, no more late nights waiting for confirmations and confluences. Just signals, entries, exits, all running 24/7 while you sleep, work, or go for a walk. You start coding. Pine Script handles the signals. A webhook sends the alert. Maybe you use a Python script or even a vibe-coding bridge to place the order.\nWithin a day or two, your first trade gets triggered. Your bot is alive. And you feel like a genius.\nBut then‚Ä¶ things go wrong.\nWhy It Falls Apart # At first, you shrug off the issues. A missed entry? Maybe the alert was delayed. A double trade? Maybe the position hit the stop-loss too early, or maybe it didn‚Äôt even close when it should have. Perhaps you accidentally ran two instances of your bot.\nBut the cracks begin to grow.\nYou start noticing inconsistencies, trades don‚Äôt execute at the right time, or worse, at the wrong price. Some days, you get no trades at all, even though your setup clearly triggered.\nOther times, your broker rejects orders because your bot didn‚Äôt handle position sizing properly. And when you try to trace the issue?\nYou realize you never added logging.\nYou built something, sure. But it‚Äôs blind, brittle, and behaving unpredictably. And the worst part? You don‚Äôt even know where it‚Äôs failing, let alone why.\nThis is where most traders quit. They realize that automation isn‚Äôt as plug-and-play as it looks. What they thought was just ‚Äúcode + strategy = freedom‚Äù turns out to be a deeper, more complex problem. One that‚Äôs less about trading and more about software engineering.\nPhotos by nenjo How Engineers Think Differently # Here‚Äôs the good news: if you have even a bit of engineering experience, or you‚Äôre willing to think like one ‚Äî you can turn this mess into something powerful.\nBecause unlike many traders who approach automation as a shortcut, engineers approach it as a system to be designed, tested, and improved.\nThe first shift is in how you structure the bot itself. Most hobbyist traders will build everything inside a single, messy script ‚Äî one that receives alerts, calculates position size, sends orders, and maybe prints a log to the terminal. But engineers know better. Systems are easier to scale, test, and debug when you break them into modules. You don‚Äôt need microservices out of the gate, but you do need separation of concerns. Have one function handle signals, another manages risk logic, another for execution, and another to monitor and log the results.\nThe next big shift is how you treat the signals. Many traders think a webhook alert should instantly trigger a trade. But as an engineer, you realize that a webhook is an event, not a command. When you receive that signal, you should run it through a series of checks. Is the market open? Are we already in a trade? Has slippage widened too much? Did this alert already trigger at the last minute?\nYour system should decide whether it‚Äôs safe, and smart to act. This is the automation equivalent of if-else logic in the real world. Not all signals should be followed blindly.\nOf course, none of these matters if your system can‚Äôt recover from failure. APIs fail. Connections drop. Brokers reject orders. Your bot must not only expect these issues, but it should also handle them gracefully. If an order doesn‚Äôt go through, try again. If MT5 is disconnected, queue the trade or trigger an alert. Always log the reason. Build in redundancy like an engineer deploying backend infrastructure, because that‚Äôs exactly what you‚Äôre doing.\nLastly, visibility is everything. Without logs, metrics, and some form of monitoring, you‚Äôll never trust your automation. You don‚Äôt need Prometheus and Grafana from day one, but you do need clear, timestamped logs of every signal received, trade executed, error handled, and position updated. Even a simple .log file and Telegram alerts can give you a massive edge when debugging.\nA Real-World Example: From Script to System # When I built my first bot, I started with a Python script that simply caught TradingView webhooks and sent market orders to MT5. It worked, until it didn‚Äôt.\nSo, I refactored. I broke it into modules: one script received signals and validated the logic. Another handled risk calculations. The third was in charge of execution, retries, and order status tracking. I wrapped the whole thing in a basic FastAPI server and added a logging layer that wrote to both file and Telegram.\nLater, I migrated the core to Golang, not because Python wasn‚Äôt working, but because I wanted tighter control over concurrency and WebSocket handling. Using goroutines and channels, I could process multiple signals and order flows in real time without blocking anything. It felt like engineering, not just coding.\nAnd when something failed, I didn‚Äôt panic. I read the logs, identified the bug, wrote a test, and fixed it. Just like I would in any other production environment.\nFinal Thoughts: Automation Isn‚Äôt a Hack ‚Äî It‚Äôs an Engineering Problem # If you\u0026rsquo;re thinking about building a trading bot, or you‚Äôve already built one that behaves like a wild animal, know this:\nYou\u0026rsquo;re not failing because your strategy is bad (or maybe).\nYou\u0026rsquo;re failing because your automation wasn‚Äôt built like software.\nAnd if you start thinking like an engineer, with modular code, fault tolerance, monitoring, and system design, you‚Äôll build bots that are stable, repeatable, and genuinely hands-off.\nNot every strategy will make money.\nBut every good system should work exactly as designed, even when it fails.\nAnd that, more than anything, is how you win in trading automation.\nü§ù Need Help Automating Your Strategy? # With over 13 years of experience in software engineering, building scalable, enterprise-grade systems, and a deep trading mindset, I help traders turn their strategies into fully automated bots using Expert Advisors, Python, or Go.\nIf you‚Äôre ready to bring your idea to life, I‚Äôd be happy to help.\nüì© Reach out to me at nenjotrade@gmail.com and let‚Äôs build it right.\n","date":"12 July 2025","externalUrl":null,"permalink":"/posts/why-most-traders-fail-at-automation-and-what-engineers-can-do-about-it/","section":"Posts","summary":"Not every strategy will make money. But every good system should work exactly as designed, even when it fails.","title":"Why Most Traders Fail at Automation (And What Engineers Can Do About It)","type":"posts"},{"content":"","date":"10 July 2025","externalUrl":null,"permalink":"/categories/back-end/","section":"Categories","summary":"","title":"Back-End","type":"categories"},{"content":"","date":"10 July 2025","externalUrl":null,"permalink":"/tags/back-end/","section":"Categories","summary":"","title":"Back-End","type":"tags"},{"content":"","date":"10 July 2025","externalUrl":null,"permalink":"/categories/design-patterns/","section":"Categories","summary":"","title":"Design Patterns","type":"categories"},{"content":"","date":"10 July 2025","externalUrl":null,"permalink":"/tags/design-patterns/","section":"Categories","summary":"","title":"Design Patterns","type":"tags"},{"content":"","date":"10 July 2025","externalUrl":null,"permalink":"/categories/go/","section":"Categories","summary":"","title":"Go","type":"categories"},{"content":"","date":"10 July 2025","externalUrl":null,"permalink":"/tags/go/","section":"Categories","summary":"","title":"Go","type":"tags"},{"content":"Imagine this: you‚Äôre in the middle of an epic coding session, coffee mug half-empty, and your trading bot is spitting out errors like a grumpy cat. You scream internally, \u0026ldquo;Why did I write this tangled mess of code?!\u0026rdquo; Been there, done that. But what if I told you there‚Äôs a way to avoid this nightmare? Enter SOLID principles, your coding safety net. Let‚Äôs explore how these principles can turn your automated trading bot into a masterpiece of maintainability and scalability. Photos by nenjo 1. Single Responsibility Principle (SRP) # \u0026ldquo;One Job, Dude. Just One Job.\u0026rdquo; # Picture this: your trading bot is like a team of specialists. Each part has its expertise. The data fetcher doesn‚Äôt care about executing trades, and the trade executor isn‚Äôt losing sleep over market analysis. That‚Äôs SRP in action.\nExample:\n// SRP: Separate data fetching logic package datafetcher type DataFetcher interface { FetchMarketData(symbol string) (MarketData, error) } type MarketData struct { Price float64 Volume float64 } // SRP: Separate strategy logic package strategy import \u0026#34;yourproject/datafetcher\u0026#34; type Strategy interface { Evaluate(data datafetcher.MarketData) (bool, error) } // SRP: Separate order execution package executor import \u0026#34;yourproject/strategy\u0026#34; type Executor interface { ExecuteTrade(strategy strategy.Strategy) error } By giving each component a single job, debugging becomes as easy as finding Waldo in a room full of Oompa-Loompas.\n2. Open/Closed Principle (OCP) # \u0026ldquo;Extend It, Don‚Äôt Break It.\u0026rdquo; # Your bot starts simple: one strategy, one order type. Then you get ambitious. New strategies, multiple order types‚Äîchaos, right? Not with OCP.\nExample:\n// Define an interface for strategies package strategy type Strategy interface { Execute(symbol string) (bool, error) } // Implement multiple strategies package strategies import \u0026#34;yourproject/strategy\u0026#34; type MACDStrategy struct {} func (s MACDStrategy) Execute(symbol string) (bool, error) { // MACD logic return true, nil } type RSIOverboughtStrategy struct {} func (s RSIOverboughtStrategy) Execute(symbol string) (bool, error) { // RSI logic return false, nil } // Add new strategies without touching existing ones! Now, you‚Äôre adding features without praying your bot doesn‚Äôt implode.\n3. Liskov Substitution Principle (LSP) # \u0026ldquo;Swap It Like It‚Äôs Hot.\u0026rdquo; # Ever tried switching out a part only to realize it breaks everything? LSP ensures you can swap components without chaos.\nExample:\npackage broker type Broker interface { PlaceOrder(symbol string, volume float64, orderType string) error } // Binance implementation package binance import \u0026#34;yourproject/broker\u0026#34; type BinanceBroker struct {} func (b BinanceBroker) PlaceOrder(symbol string, volume float64, orderType string) error { // Binance API logic return nil } // MT5 implementation package mt5 import \u0026#34;yourproject/broker\u0026#34; type MT5Broker struct {} func (m MT5Broker) PlaceOrder(symbol string, volume float64, orderType string) error { // MT5 API logic return nil } // Use brokers interchangeably func Trade(b broker.Broker, symbol string, volume float64) error { return b.PlaceOrder(symbol, volume, \u0026#34;BUY\u0026#34;) } Whether you‚Äôre trading Bitcoin or gold, your code is ready.\n4. Interface Segregation Principle (ISP) # \u0026ldquo;No Bloat, No Problem.\u0026rdquo; # Interfaces shouldn‚Äôt feel like Thanksgiving dinner‚Äîbloated and hard to handle. ISP keeps things lean.\nExample:\npackage notifier type EmailNotifier interface { SendEmail(subject, body string) error } type SMSNotifier interface { SendSMS(message, phoneNumber string) error } // Implement only what‚Äôs needed package notifications type TradeNotifier struct {} func (t TradeNotifier) SendEmail(subject, body string) error { // Email logic return nil } // SMS logic isn‚Äôt needed for this implementation Focus your interfaces like a laser, not a disco ball.\n5. Dependency Inversion Principle (DIP) # \u0026ldquo;Abstract All the Things.\u0026rdquo; # Dependencies should work for you, not the other way around. DIP keeps your code flexible.\nExample:\npackage tradingbot import \u0026#34;yourproject/broker\u0026#34; import \u0026#34;yourproject/strategy\u0026#34; type Bot struct { Broker broker.Broker Strategy strategy.Strategy } func (b Bot) Run(symbol string) error { decision, err := b.Strategy.Execute(symbol) if err != nil || !decision { return err } return b.Broker.PlaceOrder(symbol, 1.0, \u0026#34;BUY\u0026#34;) } // Inject dependencies package main import ( \u0026#34;yourproject/binance\u0026#34; \u0026#34;yourproject/strategies\u0026#34; \u0026#34;yourproject/tradingbot\u0026#34; ) func main() { bot := tradingbot.Bot{ Broker: binance.BinanceBroker{}, Strategy: strategies.MACDStrategy{}, } bot.Run(\u0026#34;BTCUSDT\u0026#34;) } Now, you can swap brokers or strategies like you‚Äôre changing outfits for a party.\nConclusion # The SOLID principles aren‚Äôt just buzzwords; they‚Äôre the Avengers of coding practices, ready to save your bot from disaster. With Golang as your hammer, these principles ensure your trading bot is:\nEasy to debug.\nReady to scale.\nResilient to change.\nSo, go forth and code responsibly. And remember, the only thing worse than spaghetti code is cold spaghetti. What‚Äôs your favorite SOLID principle? Share your thoughts (or war stories) in the comments‚Äîlet‚Äôs trade ideas like we trade stocks!\n","date":"10 July 2025","externalUrl":null,"permalink":"/posts/how-to-implement-solid-principles-in-golang-for-automated-trading-bots/","section":"Posts","summary":"The SOLID principles aren‚Äôt just buzzwords; they‚Äôre the Avengers of coding practices, ready to save your bot from disaster.","title":"How to Implement SOLID Principles in Golang for Automated Trading Bots","type":"posts"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/categories/front-end/","section":"Categories","summary":"","title":"Front-End","type":"categories"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/tags/front-end/","section":"Categories","summary":"","title":"Front-End","type":"tags"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/categories/javascript/","section":"Categories","summary":"","title":"Javascript","type":"categories"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/tags/javascript/","section":"Categories","summary":"","title":"Javascript","type":"tags"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/categories/svelte/","section":"Categories","summary":"","title":"Svelte","type":"categories"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/tags/svelte/","section":"Categories","summary":"","title":"Svelte","type":"tags"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/categories/typescript/","section":"Categories","summary":"","title":"Typescript","type":"categories"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/tags/typescript/","section":"Categories","summary":"","title":"Typescript","type":"tags"},{"content":"In the fast-paced world of frontend development, Svelte has emerged as a breath of fresh air, combining simplicity with power. When paired with TypeScript, Svelte becomes an even more formidable tool, offering type safety and enhanced developer experience. Meanwhile, SvelteKit, the full-stack application framework for Svelte, outshines its counterparts like React and Vue.js in many ways. Let‚Äôs dive into why TypeScript in Svelte is a game-changer and explore the beauty of SvelteKit compared to other popular JavaScript frameworks. Photos by nenjo Why I Love TypeScript in Svelte # 1. Type Safety Without the Noise # Svelte‚Äôs inherently simpler structure pairs beautifully with TypeScript. Defining props, types, and interfaces feels natural and uncluttered compared to other frameworks. The combination helps catch errors early while keeping your codebase clean and maintainable.\nExample: A Simple User Component\nImagine building a component to display user profiles. With TypeScript, you can define clear expectations for the props:\n\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export interface User { id: number; name: string; email: string; } export let user: User; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{user.name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Email: {user.email}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; In a real-world scenario, this ensures that only valid user data is passed to the component, preventing runtime errors when fetching or rendering user data from APIs.\n2. Intuitive Syntax with Powerful Typing # Unlike JSX or Vue templates, Svelte‚Äôs HTML-first approach means you‚Äôre writing declarative code that feels intuitive, with TypeScript enhancing it by enforcing data consistency. This reduces cognitive load while working on complex applications.\nExample: A Todo App\nWith TypeScript, you can define the structure of your to-dos and ensure type safety throughout:\n\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; interface Todo { id: number; title: string; completed: boolean; } let todos: Todo[] = [ { id: 1, title: \u0026#39;Learn Svelte\u0026#39;, completed: false }, { id: 2, title: \u0026#39;Build a project\u0026#39;, completed: false } ]; function toggleCompleted(id: number) { todos = todos.map(todo =\u0026gt; todo.id === id ? { ...todo, completed: !todo.completed } : todo ); } \u0026lt;/script\u0026gt; \u0026lt;ul\u0026gt; {#each todos as todo} \u0026lt;li\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:checked={todo.completed} on:change={() =\u0026gt; toggleCompleted(todo.id)} /\u0026gt; {todo.title} \u0026lt;/li\u0026gt; {/each} \u0026lt;/ul\u0026gt; This example demonstrates a small but functional application where TypeScript ensures the consistency and integrity of your data.\n3. Improved Tooling # With TypeScript, Svelte‚Äôs already excellent tooling gets a significant boost. Autocompletion, type-checking, and error detection within IDEs like VS Code ensure you‚Äôre more productive and confident in your work. For example, if you mistype a property name in the Todo interface, your IDE will highlight the error immediately.\n4. Seamless Integration # Using TypeScript in Svelte requires minimal configuration. The community has ensured a smooth developer experience, making it easy to adopt and enjoy TypeScript‚Äôs benefits without extensive setup.\nReal-World Scenario: API Integration\nWhen fetching data from an external API, TypeScript can define the expected structure, preventing potential issues:\n\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { onMount } from \u0026#39;svelte\u0026#39;; interface Post { id: number; title: string; body: string; } let posts: Post[] = []; onMount(async () =\u0026gt; { const response = await fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;); posts = await response.json(); }); \u0026lt;/script\u0026gt; \u0026lt;ul\u0026gt; {#each posts as post} \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt;{post.title}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{post.body}\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; {/each} \u0026lt;/ul\u0026gt; This ensures that your posts variable matches the expected structure, and any discrepancies are caught at compile time rather than runtime.\nThe Beauty of SvelteKit Compared to React and Vue.js # 1. Zero Boilerplate # Unlike React (with Next.js) or Vue.js (with Nuxt.js), SvelteKit provides a much cleaner starting point. The lack of excessive boilerplate code means developers can focus on building features rather than managing configuration.\nExample: File-Based Routing\nSvelteKit‚Äôs file-based routing is straightforward and intuitive. For instance, creating a new route is as simple as adding a file in the routes directory:\nsrc/routes ‚îú‚îÄ‚îÄ index.svelte ‚îú‚îÄ‚îÄ about.svelte ‚îú‚îÄ‚îÄ blog ‚îÇ ‚îî‚îÄ‚îÄ [slug].svelte This simplicity reduces setup time and improves developer productivity.\n2. Truly Reactive # While React and Vue.js employ reactivity via hooks or computed properties, Svelte‚Äôs reactivity is built into its core. Variables automatically update the DOM when they change, making the code more intuitive and less verbose.\nExample: Dynamic Form Handling\n\u0026lt;script\u0026gt; let formData = { name: \u0026#39;\u0026#39;, email: \u0026#39;\u0026#39; }; function handleSubmit() { console.log(\u0026#39;Form submitted:\u0026#39;, formData); } \u0026lt;/script\u0026gt; \u0026lt;form on:submit|preventDefault={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; bind:value={formData.name} placeholder=\u0026#34;Name\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; bind:value={formData.email} placeholder=\u0026#34;Email\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; This simplicity makes it easier to build dynamic and interactive applications.\n3. Built-In Optimizations # SvelteKit‚Äôs approach to rendering ‚Äî whether it‚Äôs SSR (Server-Side Rendering), SSG (Static Site Generation), or client-side ‚Äî is seamless and highly performant out of the box. This contrasts with the sometimes-cumbersome configurations required in React and Vue.js ecosystems.\n4. Smaller Bundle Sizes # Svelte‚Äôs compiler approach eliminates the runtime overhead common in React and Vue.js, resulting in significantly smaller bundle sizes and faster load times. For businesses, this translates into better SEO and user retention.\n5. Simplified State Management # State management in Svelte is refreshingly straightforward, with no need for additional libraries like Redux or Vuex. Svelte‚Äôs writable stores provide a lightweight, built-in solution for managing global state.\nExample: Shared State Across Components\n// store.ts import { writable } from \u0026#39;svelte/store\u0026#39;; export const count = writable(0); \u0026lt;!-- Counter.svelte --\u0026gt; \u0026lt;script\u0026gt; import { count } from \u0026#39;./store\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;button on:click={() =\u0026gt; count.update(n =\u0026gt; n + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Count: {$count}\u0026lt;/p\u0026gt; This simplicity is a significant advantage for teams and solo developers alike.\nWhy Choose SvelteKit and TypeScript? # The combination of SvelteKit and TypeScript represents the best of both worlds ‚Äî a modern framework designed for simplicity and speed, paired with a robust type system that ensures reliability and scalability. Whether you‚Äôre building a personal project or a production-grade application, this stack is worth considering.\nWhat‚Äôs your experience with SvelteKit and TypeScript? Let‚Äôs discuss in the comments below!\n","date":"8 July 2025","externalUrl":null,"permalink":"/posts/why-i-love-typescript-in-svelte-and-the-beauty-of-sveltekit-compared-to-other-js-frameworks/","section":"Posts","summary":"The combination of SvelteKit and TypeScript represents the best of both worlds that ensures reliability and scalability.","title":"Why I Love TypeScript in Svelte, and the Beauty of SvelteKit Compared to Other JS Frameworks","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]